#!/usr/bin/env bash
#
# Usage: huprestarter [--loop] COMMAND ARGS..
# 
# Runs the given command in a subprocess. When this process receives
# a SIGHUP signal, the subprocess is killed (with SIGTERM) and started again.
# If the subprocess exits on its own, this process exits too with the same exit code
#
# If --loop is passed, the command is restarted even if it exits on its own


# Turn on job control, which puts background processes into their own process group,
# allowing us to kill the whole process group at once, instead of having to mess
# with individual pids
set -m

loop=
if [[ "$1" == "--loop" ]]; then
  shift
  loop=1
fi

# Save the arguments so we can call them in a function
args=( "$@" )

echo "[huprestarter] Main pid that listens to SIGHUP for restarting the command is $$"

instance=1
pid=
code=
start() {
  "${args[@]}" &
  pid=$!

  echo "[huprestarter] Started instance $instance with pid $pid, waiting for it to exit"
  # {} and 2>/dev/null to prevent any job control output being shown
  { wait "$pid"; } 2>/dev/null
  code=$?

  instance=$(( instance + 1 ))
}

stop() {
  echo "[huprestarter] SIGHUP received, stopping instance $instance by killing its pid $pid"
  tokill=$pid
  # By unsetting the pid before killing the process we signal that this function stopped
  # the process, instead of it exiting on its own
  pid=
  kill -TERM "-$tokill"
}

run-once() {
  # Restart the process only if the pid is empty, which can only happen if the stop
  # function above is called to kill the previous process (or in the initial run).
  while [[ -z "$pid" ]]; do
    start
  done
  pid=

  echo "[huprestarter] Instance exited on its own with exit code $code"
  return "$code"
}

run-forever() {
  while true; do
    run-once
  done
}

trap stop HUP
trap '[[ -n "$pid" ]] && kill -TERM "-$pid"' exit

if [[ -n "$loop" ]]; then
  run-forever
else
  run-once
  exit "$!"
fi
